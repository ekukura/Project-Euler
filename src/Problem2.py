#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 17 19:26:26 2017

@author: emilykukura
"""

'''
Each new term in the Fibonacci sequence is generated by adding the previous 
two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed 
four million, find the sum of the even-valued terms.
'''

import time, math

'''
note that since odd + even = odd and odd + odd = even,
terms go by pattern o e o o e o o e ... etc.
so that even terms are exactly f(3n+2)'s
'''
def solution_1():
########################
#Solution 1
# uses roots of generating function
########################

    #fibonnaci function, where f(0) = f(1) = 1, f(2) = 2
    def f(n):
        alpha = (1 + math.sqrt(5))/2
        beta = (1 - math.sqrt(5))/2
        return round((alpha**(n+1)-beta**(n+1))/math.sqrt(5))

    i = 2
    mySum = 0
    curVal = f(2)
    done = False
    while not done :
        mySum += curVal
        i += 3
        curVal = f(i)
        if (curVal > 4000000):
            done = True

    return mySum

'''
From the Fibonnaci recurrence we can derive a 
recurrence for even terms:

    f(3n+2) = 4*f(3(n-1)+2) + f(3(n-2)+2)

So setting g(n) = f(3n+2) we have the recurrence:

    g(n) = 4*g(n-1) + g(n-2)

Derivation:
-----------
f(3n+2) = f(3n+1) + f(3n)
        = f(3n) + 2*f(3n-1) + f(3n-2)
        = 3*f(3n-1) + f(3n-2) + f(3n-3) + f(3n-4)
        = 3*f(3n-1) + f(3n-1) + f(3n-4)
        = 4*f(3n-1) + f(3n-4)
        = 4*f(3(n-1)+2) + f(3(n-2)+2)
'''

def g(n):
    if n == 0:
        return 2
    elif n == 1:
        return 8
    else:
        return 4*g(n-1) + g(n-2)
        
def solution_2():
##########################
#Solution 2
# brute force/recursion
# (simplified)
##########################
#could make this even faster by using a dictionary to store previously calculated 
#g(n) values, or do dynamically instead of recursively (see solution 3)
 
    i = 0
    mySum = 0
    curVal = g(0)
    while (curVal <= 4000000):
        mySum += curVal
        i += 1
        curVal = g(i)
        
    return mySum

#dynamic, using recurrence for g: g(n) = 4*g(n-1) + g(n-2)
def solution_3():
    
    #g_dict a dictionary to enable dynamic build-up of the g-recurrence
    #note g_dict[i] = g(i) (same recurrence which is given same initial conditions)
    g_dict = {0:g(0), 1:g(1)}
    mySum =  g_dict[0] 
    curVal = g_dict[1]
    i = 1
    while (curVal <= 4000000):
        mySum += curVal
        i += 1
        #add next value to dictionary
        g_dict[i] = 4*g_dict[i-1] + g_dict[i-2]
        #compute new sum
        curVal = g_dict[i]
        
    return mySum


if __name__ == '__main__':
    #Answer: 4613732
    
    start = time.time()
    res_1 = solution_1()
    end = time.time()
    print("result = {}. Took {} seconds".format(res_1, end-start))

    start = time.time()
    res_2 = solution_2()
    end = time.time()
    print("result = {}. Took {} seconds".format(res_2, end-start))

    start = time.time()
    res_3 = solution_3()
    end = time.time()
    print("result = {}. Took {} seconds".format(res_3, end-start))
    
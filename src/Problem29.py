#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec  6 10:42:10 2017

@author: emilykukura

Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, 
we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 
and 2 ≤ b ≤ 100?

"""

import numpy as np
import time, itertools, math

def brute(max_a, max_b):
    s = set()
    for a in range(2, max_a+1):
        for b in range(2, max_b+1):
            s = s.union({pow(a,b)})
           # print(s)
           
    return s

#so a = k^p, so since k < a, already accounted for some of a^b = (k)^p*b
#this function returns the number you HAVENT accounted for 
#(knowing that p is the highest power s.t. a = k^p)
def get_num_new(p): #assumed max b = M_b = 100, and M_a = 100. General version needs M_a, M_b as inputs

    if p == 2:
        n = 49 #(49 = 50-1)
        
    elif p == 3: 
        #floor(100/3) = 33, so accounted for AT LEAST k^(3*b) for 2 <= b <= 33
        #also need to determine when already counted (k^2)^(3/2)b (b<=66) 
            # -- e.g. the even b betwen 34 and 66
        m3 = 33
        n2 = math.floor((66-34)/2) + 1
        n = m3-1 + n2 #32 numbers between 2 and 33 #should NOT add 32 + 17 = 49 (50)

    elif p == 4:   
        #floor(100/4) = 25, so accounted for AT LEAST k^(4*b) for 2 <= b <= 25
        #also need to determine when already counted (k^2)^(2)b (b<=50) 
        #also need to determine when already counted (k^3)^(4/3)b (b<=75) 
            # -- (4/3)b an integer when 4b multiple of 3. equiv when b mult of 3
            #since 4,3 coprime
        m4 = 25
        n2 = 25
        n3 = math.floor((75 - 51)/3) + 1
        n = (m4-1) + n2 + n3  #should NOT add 49 + 9 = 58 (99-58 = 41)

    elif p == 5:
        #floor(100/5) = 20, so accounted for AT LEAST k^(5*b) for 2 <= b <= 20
        #also need to determine when already counted (k^2)^(5/2)b (21<=b<=40) 
            # -- (5/2)b an integer when 5b multiple of 2. equiv when b mult of 2
            #since 5,2 coprime
        #also need to determine when already counted (k^3)^(5/3)b (21<=b<=60 and not already counted) 
            # -- (5/3)b an integer when 5b multiple of 3. equiv when b mult of 3
            # -- not already counted when b in [41,60] or b not mult of 2. 
            # -- also: 21, 27, 33, 39
            #since 5,3 coprime
        #also need to determine when already counted (k^4)^(5/4)b (21<=b<=80 and not already counted) 
            # -- (5/4)b an integer when 5b multiple of 4. equiv when b mult of 4
            #since 5,4 coprime
            # so all multiples of 4 >= 61 not yet counted. 64,68,72,76,80
            # any multiple of 4 is also multiple of 2 so multiples <= 40 counted
            # still need multiples of 4 not mult of 3 in range(41,60) #--44, 52, 56 
            
        m5 = 20
        n2 = math.floor((40-21)/2) + 1 #10
        n3 = math.floor((60 - 41)/3) + 1 + 4 #7 + 4 = 11
        n4 = math.floor((80 - 61)/4) + 1 + 3 #5 + 3 = 8
        n = (m5-1) + n2 + n3 + n4  #19 + 10 + 11 + 8 = 48 (51)
        
    elif p == 6:
        #floor(100/6) = 16, so accounted for AT LEAST k^(6*b) for 2 <= b <= 16
        #also need to determine when already counted (k^2)^(3)b (17<=b<=33) 
        #also need to determine when already counted (k^3)^(2)b (34<=b<=50)
        #also need to determine when already counted (k^4)^(3/2)b (51<=b<=66 and not already counted) 
            # -- (3/2)b an integer when 3b multiple of 2. equiv when b mult of 2
            #since 3,2 coprime
            # so all multiples of 2 in range [51, 66] not yet counted.
        #also need to determine when already counted (k^5)^(6/5)b (51<=b<=83 and not already counted) 
            # -- (6/5)b an integer when 6b multiple of 5. equiv when b mult of 5
            #since 6,5 coprime
            # so all multiples of 5 in [67,83] not yet counted: 70, 75, 80
            # any muliple of 5 not a multiple of 2 in [51,66] not counted: 55, 65

        m6 = 16
        n2 = 33 - 16
        n3 = 50 - 33
        n4 = math.floor((66 - 51)/2) + 1  #8
        n5 = math.floor((83 - 67)/5) + 2 #5
        n = (m6-1) + n2 + n3 + n4 + n5 # 49 + 13 = 62 (37)
    
    #print("returning {}...".format(99-n))
    return 100 - 1 - n #100 = M_a
        
def opt(M_a, M_b):
    total = 0
    for a in range(2,M_a+1):
        #print("a = ", a)
        hp = math.floor(math.log2(a))
        power_found = False
        p = hp
        #find highest power p s.t. a = k^p
        while p >= 2 and not power_found:
            #print("p = ", p)
            k = pow(a,1/p)
            if k.is_integer(): #then a = k^p, and p is the LARGEST such power
                #print("for a = {} and p = {}, k = {}".format(a,p,k))
                power_found = True
                to_add = get_num_new(p)
                #print("adding {}...".format(to_add))
                total += to_add #right now assumed M_b = 100
            else: #check next lowest power
                p -= 1
                
        if not power_found:
            #print("adding 99")
            total += M_a - 1
            
    return total

 #so a = k^p, so since k < a, already accounted for some of a^b = (k)^p*b
#this function returns the number you HAVENT accounted for 
#(knowing that p is the highest power s.t. a = k^p)
def get_num_new_gen(p, M_a, M_b): 
    #print("get_num_new_gen called with arguments p = {}, M_a = {}, M_b = {}".format(p, M_a, M_b))
    #Have a = k^p = (k^l)^(p/l)*b for 1<=l<=p-1
    unaccounted = {i for i in range(2,M_b+1)}
    #n_accounted = [0 for i in range(p)] # n_accounted[j] = those accounted for by k^j but NOT by k^i for i < j. by conv. acc[0] = 0
    for l in range(1,p): #looking at (k^l)^(p/l)*b in this loop
    #first put p/l in reduced form
        #if x = gcd(l,p), p/l = (p/x)/(l/x) and (p/x, l/x) = (p',l') are co-prime
        x = math.gcd(l,p) # (k^l)^(p'/l')*b 
        max_mult = int(math.floor(M_b/(p/l)))
        d = int(l/x)
        #since p',l' coprime (p'/l')*b an integer <> p'*b mult of l' <> b mult of l' = d
        to_remove = {j*d for j in range(1, int(max_mult/d) + 1)}
        unaccounted = unaccounted - to_remove
        #print("for l = {}, x = {}, max_mult = {}, d = {}\n".format(l,x,max_mult,d))
        #print("removing:\n{}\n".format(to_remove))
        #print("unaccounted = ", unaccounted)
   
    return len(unaccounted)           

       
def opt_gen(M_a, M_b):
    total = 0
    for a in range(2,M_a+1):
        #print("a = ", a)
        hp = math.floor(math.log2(a))
        power_found = False
        p = hp
        #find highest power p s.t. a = k^p
        while p >= 2 and not power_found:
            #print("p = ", p)
            k = pow(a,1/p)
            if k.is_integer(): #then a = k^p, and p is the LARGEST such power
                #print("for a = {} and p = {}, k = {}".format(a,p,k))
                power_found = True
                to_add = get_num_new_gen(p, M_a, M_b)
                #print("adding {}...".format(to_add))
                total += to_add #right now assumed M_b = 100
            else: #check next lowest power
                p -= 1
                
        if not power_found:
            #print("adding {}".format(M_a - 1))
            total += M_a - 1
            
    return total    

    
#'''
m = 10240
print("m = ", m)

num_trials = 1

total_opt = 0
total_brute = 0

for i in range(num_trials):
    
    start = time.time()
    res = opt_gen(m,m)
    end = time.time()
    total_opt += end - start

print("The answer is {}\nTook {} seconds".format(res, total_opt/num_trials))

#start = time.time()
#res = opt(m,m)
#end = time.time()
#print("The answer is {}\nTook {} seconds".format(res, end-start))

'''
for i in range(num_trials):
    
    start = time.time()
    res = len(brute(m,m))
    end = time.time()
    total_brute += end - start

print("The answer is {}\nTook {} seconds".format(res, total_brute/num_trials))
'''
#'''

#s = set(itertools.product(range(2,6), repeat=2))
#print(s)




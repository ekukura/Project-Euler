#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec  6 10:42:10 2017

@author: emilykukura

Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, 
we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 
and 2 ≤ b ≤ 100?

"""

import numpy as np
import time, itertools, math

#brute force
def solution_1(max_a, max_b):
    s = set()
    for a in range(2, max_a+1):
        for b in range(2, max_b+1):
            s = s.union({pow(a,b)})      
              
    return len(s)


########################################################################
# NOTE: For this helper function for solution_2, 
# it is assumed max b = M_b = 100 
# General version needs M_a, M_b as inputs.
# This version is just to help get intuition for the general version
########################################################################
# Here we have a = k^p, so since k < a, already accounted for some of 
# a^b = (k)^p*b (since loop over a-values is in increasing order).
# This function returns the number you HAVENT accounted for 
# (knowing that p is the highest power s.t. a = k^p)
def get_num_new(p): 

    if p == 2: 
        # a = k^2, so a^b = k^(2*b); since k < a, have already
        # accounted for k^b' for b' = 2b, where b = 2...50
        n = 49 #(49 = 50-1) # n is the number we HAVE accounted for already
        
    elif p == 3: 
        #floor(100/3) = 33, so accounted for AT LEAST k^(3*b) for 2 <= b <= 33
        #also need to determine when already counted (k^2)^(3/2)b (b<=66) 
            # -- e.g. the even b betwen 34 and 66
        m3 = 33
        n2 = math.floor((66-34)/2) + 1
        n = m3-1 + n2 #32 numbers between 2 and 33 
        #should NOT add 32 + 17 = 49 (new: 50)

    elif p == 4:   
        #floor(100/4) = 25, so accounted for AT LEAST k^(4*b) for 2 <= b <= 25
        #also need to determine when already counted (k^2)^(2)b (b<=50) 
        #also need to determine when already counted (k^3)^(4/3)b (b<=75) 
            # -- (4/3)b an integer when 4b multiple of 3. equiv when b mult of 3
            #since 4,3 coprime
        m4 = 25
        n2 = 25
        n3 = math.floor((75 - 51)/3) + 1
        n = (m4-1) + n2 + n3  #should NOT add 49 + 9 = 58 (new: 99-58 = 41)

    elif p == 5:
        #floor(100/5) = 20, so accounted for AT LEAST k^(5*b) for 2 <= b <= 20
        #also need to determine when already counted (k^2)^(5/2)b (21<=b<=40) 
            # -- (5/2)b an integer when 5b multiple of 2. equiv when b mult of 2
            #since 5,2 coprime
        #also need to determine when already counted (k^3)^(5/3)b (21<=b<=60 and not already counted) 
            # -- (5/3)b an integer when 5b multiple of 3. equiv when b mult of 3
            # -- not already counted when b in [41,60] or b not mult of 2. 
            # -- also: 21, 27, 33, 39
            #since 5,3 coprime
        #also need to determine when already counted (k^4)^(5/4)b (21<=b<=80 and not already counted) 
            # -- (5/4)b an integer when 5b multiple of 4. equiv when b mult of 4
            #since 5,4 coprime
            # so all multiples of 4 >= 61 not yet counted. 64,68,72,76,80
            # any multiple of 4 is also multiple of 2 so multiples <= 40 counted
            # still need multiples of 4 not mult of 3 in range(41,60) #--44, 52, 56 
            
        m5 = 20
        n2 = math.floor((40-21)/2) + 1 #10
        n3 = math.floor((60 - 41)/3) + 1 + 4 #7 + 4 = 11
        n4 = math.floor((80 - 61)/4) + 1 + 3 #5 + 3 = 8
        n = (m5-1) + n2 + n3 + n4  #19 + 10 + 11 + 8 = 48 (new: 51)
      
    # only need to check up to p = 6 b/c 2 = min(a_values) and 2^7 = 128 > 100  
    elif p == 6:
        #floor(100/6) = 16, so accounted for AT LEAST k^(6*b) for 2 <= b <= 16
        #also need to determine when already counted (k^2)^(3)b (17<=b<=33) 
        #also need to determine when already counted (k^3)^(2)b (34<=b<=50)
        #also need to determine when already counted (k^4)^(3/2)b (51<=b<=66 and not already counted) 
            # -- (3/2)b an integer when 3b multiple of 2. equiv when b mult of 2
            #since 3,2 coprime
            # so all multiples of 2 in range [51, 66] not yet counted.
        #also need to determine when already counted (k^5)^(6/5)b (51<=b<=83 and not already counted) 
            # -- (6/5)b an integer when 6b multiple of 5. equiv when b mult of 5
            #since 6,5 coprime
            # so all multiples of 5 in [67,83] not yet counted: 70, 75, 80
            # any muliple of 5 not a multiple of 2 in [51,66] not counted: 55, 65

        m6 = 16
        n2 = 33 - 16
        n3 = 50 - 33
        n4 = math.floor((66 - 51)/2) + 1  #8
        n5 = math.floor((83 - 67)/5) + 2 #5
        n = (m6-1) + n2 + n3 + n4 + n5 # 49 + 13 = 62 (new: 37)
    
    #print("returning {}...".format(99-n))
    return 100 - 1 - n #100 = M_b 

        
def solution_2(M_a):
    total = 0
    for a in range(2,M_a+1):
        #print("a = ", a)
        hp = math.floor(math.log2(a))
        power_found = False
        p = hp
        #find highest power p s.t. a = k^p
        while p >= 2 and not power_found:
            #print("p = ", p)
            k = pow(a,1/p)
            if k.is_integer(): #then a = k^p, and p is the LARGEST such power
                #print("for a = {} and p = {}, k = {}".format(a,p,k))
                power_found = True
                to_add = get_num_new(p)
                #print("adding {}...".format(to_add))
                total += to_add #right now assumed M_b = 100
            else: #check next lowest power
                p -= 1
                
        if not power_found:
            #print("adding 99")
            total += M_a - 1
            
    return total


# Here a = k^p, so since k < a, already accounted for some of a^b = (k)^p*b.
# %his function returns the number you HAVENT accounted for 
# (knowing that p is the highest power s.t. a = k^p)
def get_num_new_gen(p, M_b): 
    #print("get_num_new_gen called with arguments p = {}, M_a = {}, M_b = {}".format(p, M_a, M_b))
    # Have a = k^p = (k^l)^(p/l) where for 1<=l<=p-1,since k^l < k^p, we
    # have already accounted for some of a^b = (k^l)^(p*b/l)
    unaccounted = {i for i in range(2,M_b+1)} 
    # at first assume haven't acounted for any yet; then remove ones found to 
    # have been already accounted for
    for l in range(1,p): #looking at (k^l)^(p/l)*b in this loop
    #first put p/l in reduced form
        #if x = gcd(l,p), p/l = (p/x)/(l/x) = (p',l'), and (p',l') are co-prime
        x = math.gcd(l,p) # (k^l)^(p'/l')*b 
        #max_b_val, below, is the maximum b s.t. (p/l)*b <= M_b
        max_b_val = int(math.floor(M_b/(p/l)))
        l_prime = int(l/x) # since x is the gcd of l and p, x divides l, so 
        # we already know l/x is an integer, but this conversion just ensures that
        # it is interpreted as such by python
        
        # since p',l' coprime (p'/l')*b an integer <> p'*b mult of l' <> b mult of l'
        # Thus since a^b = (k^l)^(p'/l')*b already accounted for <> (p'/l')*b an integer,
        # we have that a^b = (k^l)^(p'/l')*b already accounted for  <> b mult of l'
        # <> b = j*l' for 1 <= j <= floor(max_b_val/l')
        to_remove = {j*l_prime for j in range(1, int(max_b_val/l_prime) + 1)}
        unaccounted = unaccounted - to_remove
        #print("for l = {}, x = {}, max_b_val = {}, l_prime = {}\n".format(l,x,max_b_val,l_prime))
        #print("removing:\n{}\n".format(to_remove))
        #print("unaccounted = ", unaccounted)
   
    return len(unaccounted)           


# General solution for any M_a, M_b  
def solution_3(M_a, M_b):
    total = 0
    for a in range(2,M_a+1):
        #print("a = ", a)
        hp = math.floor(math.log2(a))
        power_found = False
        p = hp
        #find highest power p s.t. a = k^p
        while p >= 2 and not power_found:
            #print("p = ", p)
            k = pow(a,1/p)
            if k.is_integer(): #then a = k^p, and p is the LARGEST such power
                #print("for a = {} and p = {}, k = {}".format(a,p,k))
                power_found = True
                to_add = get_num_new_gen(p, M_b)
                #print("adding {}...".format(to_add))
                total += to_add 
            else: #check next lowest power
                p -= 1
                
        if not power_found:
            #print("adding {}".format(M_a - 1))
            total += M_a - 1
            
    return total  


def solution_4(M_a, M_b):

    s = set(itertools.product(range(2, M_a + 1), range(2, M_b + 1)))
    #print(s)
    s2 = {pow(a, b) for a, b in s}
    #print(s2)
    return len(s2)


    
if __name__ == '__main__':

    num = 100
    #num = 10240
    print("num = ", num)
    
    #'''don't do this one for num >= 120 (at 120 takes ~4.5 s)
    start = time.time()
    res_1 = solution_1(num, num)
    end = time.time()
    print("res_1 = {}\nTook {} seconds".format(res_1, end-start))  
    # for num = 100, takes ~1.6 s
    #'''
    
    # print(solution_2(100))
    # Note solution_2 IS NOT GENERAL. Requires num = 100 (max_b = 100 specifically is what is required)
        
    start = time.time()
    res_3 = solution_3(num, num)
    end = time.time()
    print("res_3 = {}\nTook {} seconds".format(res_3, end-start))   
    # for num = 100, takes ~0.00048 s
    
    #'''don't do this one for num >= 800 (at 800 takes ~4.8 s)'
    start = time.time()
    res_4 = solution_4(num, num)
    end = time.time()
    print("res_4 = {}\nTook {} seconds".format(res_4, end-start))    
    # for num = 100, takes ~0.011 s 
    #'''
    
    # Answer: 9183

    